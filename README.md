# JavaDeveloper

Материалы для собеседования на позицию java developer.

<!--ts-->
<!--te-->

## Общие вопросы

#### Если нажать поиск в гугл, что происходит под капотом?
<details><summary markdown="span">Ответ</summary>

ToDo: развернутый большой ответ

</details>

---

#### Расскажите про клиент-серверную архитектуру
ToDo: небольшой ответ (поэтому без details)

---

#### Что такое xml, как он связан с xsd?
ToDo: небольшой ответ (поэтому без details)

---

#### Чем удобен json, есть ли у него инструменты для проведения валидации?
ToDo: ответ

---

#### Что такое сериализация и десериализация?
ToDo: ответ

---

#### Какие знаете http методы? какие из них персистентные?
ToDo: ответ

---

#### Зачем нужны куки?
ToDo: ответ

---

#### Чем аутентификация отличается от идентификации?
ToDo: ответ

---

#### REST vs SOAP
ToDo: ответ

---

#### RESTful api и JSON-pure api в чем отличие?
ToDo: ответ

---

#### Расскажите про CRUD
ToDo: ответ

---

#### Как согласно CAP теореме я должен выбирать элементы для фронт и бэк систем (Базы данных, системы резервирования и проч)?
ToDo: ответ

---

## Сервера приложений

#### Чем сервер приложений отличается от web сервера?
ToDo: ответ

---

#### Какие упрощения для приложения предоставляет app server?
ToDo: ответ

---

#### Вам нужно настроить TLS в вашем приложении. Какие есть способы реализации этого, если приложение установлено не standalone?
ToDo: ответ

---

#### Чем отличается jar от war?
ToDo: ответ

---

#### Зачем нужен в общем случае кластер WAS? могу ли я использовать кластер для распределения нагрузки?
ToDo: ответ

---

## Java EE

#### Назовите принципы ООП (с примерами)
ToDo: ответ

---

#### Расскажите про String пул
ToDo: ответ

---

#### Что будет если вызвать intern от сроки, которой еще нет в пуле?
ToDo: ответ

---

#### Что хранится в стеке, а что в хипе?
ToDo: ответ

---
#### Расскажите, как работает GC
ToDo: ответ

---

#### Назовите методы класса Object
ToDo: ответ

---

#### Расскажите про принципы happens before
ToDo: ответ

---

#### Как я могу создать поток?
ToDo: ответ

---

#### Что такое thread-safe?
ToDo: ответ

---

#### Будет ли ошибка, если вызвать wait не из блока synchronize?
ToDo: ответ

---

#### Использовали ли Вы что-то из пакета java.concurrent.atomic?
ToDo: ответ

---

#### Что такое оптимистичная блокировка?
ToDo: ответ

---

#### Расскажите про synchronize блоки и методы, чем отличаются? Что такое монитор?
ToDo: ответ

---

#### Как я могу пустить не один поток в синхронизированный блок, а например не больше пяти?
ToDo: ответ

---

#### Влияет ли как то volatile на оптимизации, выполняемые JVM?
ToDo: ответ

---

#### Назовите concurrent коллекцию. Как осущестляется расспаралеливание в ConcurrentHashMap?
ToDo: ответ

---

#### Что такое live lock и deadlock
ToDo: ответ

---

#### Расскажите про структуру исключений. Что значит обрабатываемые и необрабатываемые исключения?
ToDo: ответ

---

#### Могу ли я создавать свои исключения?
ToDo: ответ

---

#### Как в коде мне получить StackOverflow и OutOfMemory намеренно?
ToDo: ответ

---


## Коллекции

####  Какие существуют коллекции?
ToDo: ответ

---

#### Какую коллекцию мне нужно использовать для хранения отсортированного набора данных?
ToDo: ответ

---

#### Каким образом мы понимаем, в какой бакет положить элемент в HashMap?
ToDo: ответ

---

#### Что будет, если в один бакет попали элементы equals которых вернул true. Перезапишется ключ или значение? Останется старое value или новое?
ToDo: ответ

---

#### Что лучше ArrayList или LinkedList, если мне нужно будет в большой массив вставлять много элементов в середину?
ToDo: ответ

---

#### У array copy стоит нотация native, что значит эта нотация?
ToDo: ответ

---

#### Какие есть способы пройтись по коллекции?
ToDo: ответ

---

#### Что такое функциональный интерфейс? В чем его основное назначение?
ToDo: ответ

---

#### Сколько может быть терминальных операторов внутри стрима?
ToDo: ответ

---

#### Что внутри парралел стрима?
ToDo: ответ

---

#### Сколько тредов внутри парралел стрима по умолчанию? Могу ли я как-то сам задать их количество?
ToDo: ответ

---

## реактивное программирование
расскажите что такое проблема 10к и как реактивное программирование позволяет ее решить
почему получить ддос легче именно на реакте
можно ли анализировать ошибки по стектрейсу в реактивном приложении
у меня небольшой веб сервер со сложной логикой на бэке. запрос в среднем занимет 100мс.
При нагрузке 1к запросов в секунду есть ли мне смысл переписывать свое приложение под реакт?
какой есть у спринг модуль для реактива
что общего у SEDA архитектуры и AKKA

## паттерны разработки
какие существуют типы паттернов
чем отличается абстрактная фабрика от фабричного метода
почему синглтон считается антипаттерном
назовите примеры паттернов которые недавно использовали и какие были задачи
расскажите про паттерн сага
какие паттерны использует спринг?

## архитектура

#### DDD. Расскажите в чем основная суть подхода
ToDo: ответ

#### принцип CQRS в чем состоит
ToDo: ответ

#### Clean Architecture
ToDo: ответ

#### onion architecture
ToDo: ответ

#### screaming architecture
ToDo: ответ

#### SOA архитектура
ToDo: ответ

### SEDA архитектура
ToDo: ответ

#### монолиит, микросервисы и сервисмеш
ToDo: ответ

#### SOLID
ToDo: ответ

#### принцип KISS, DRY

## spring
чем отличается DI от IoC
расскажите про propagation (распространение транзакций)
сколько существует уровней изоляции транзакций
скоупы бинов
опишите цикл жизни бина
выполнится предестрой у прототайп бина?
как я могу изменить бин перед помещением его в контейнер не изменяя код класса
где я могу ставить аннотацию autowired
в чем преимущество спринг для тестирования
чем мок отличается от spy

в чем преимущество spring boot

что будет результатом работы стартера?
чем лучше java 11 перед 8 для контейнеров
расскажите зачем применяется аннотация Conditional

работали ли с какими нибудь ORM?
расскажите сколько существует уровней кэширования?
могу как то я сказать JVM что этот объект нужно кэшировать?
какие знаете стратегии кэширования?
может быть с какими то сложными ошибками сталкивались в работе?
что такое уровни кэширования

## DevOps
#### Какими системами сборками пользовались?
**Jenkins** — это сервер непрерывной интеграции, написанный на Java. Он является чрезвычайно расширяемой системой из-за внушительной экосистемы разнообразных плагинов. 
Настройка пайплайна осуществляется в декларативном или императивном стиле на языке Groovy, а сам файл конфигурации (Jenkinsfile) располагается в системе контроля версий вместе с исходным кодом.

---

#### Отличие CI от CD
**Непрерывная интеграция (CI)** — первичный, базовый процесс обновления ПО, в рамках которого все изменения на уровне кода вносятся в единый центральный репозиторий. 
Такое внесение принято называть слиянием. После каждого слияния (которое проходит по несколько раз в день) в изменяемой системе происходит 
- автоматическая сборка (часто приложение упаковывается в Docker) 
- тестирование (проверка конкретных модулей кода, UI, производительности, надёжности API). 

Таким образом разработчики страхуются от слишком поздних обнаружений проблем в обновлениях.

**Непрерывная доставка (CD)** — CI + CD. Следующий после CI уровень. Теперь новая версия не только создаётся и тестируется при каждом изменении кода, регистрируемом в репозитории, 
но и может быть оперативно запущена по одному нажатию кнопки развёртывания. Однако запуск развёртывания всё ещё происходит вручную — ту самую кнопку всё же надо кому-то нажать. 
Этот метод позволяет выпускать изменения небольшими партиями, которые легко изменить или устранить в случае необходимости.

*Дополнительно*
**Непрерывное развёртывание (CD)** — CI +CD + CD. После автоматизации релиза остаётся один ручной этап: одобрение и запуск развёртывания в продакшен. 
Практика непрерывного развёртывания упраздняет и это, не требуя непосредственного утверждения со стороны разработчика. Все изменения развёртываются автоматически.

---

#### Отличие Jenkins от Teamcity
**Jenkins:**

Плюсы:
- бесплатный инструмент CI
- может интегрироваться практически с любой внешней программой, используемой для разработки приложений. Это позволяет использовать контейнерные технологии, такие как Docker и Kubernetes, из коробки.

Минусы:
- устаревший интерфейс
- плохая документация

**Teamcity**

Плюсы:
- Хорошая документация и поддержка
- Простота настройки
- Современный интерфейс

Минусы:
- Платный для Enterprise
- Ручное обновление

---

#### Что такое pipeline в Jenkins
Jenkins Pipeline — набор плагинов, позволяющий определить жизненный цикл сборки и доставки приложения. 
Он представляет собой Groovy-скрипт с использованием Jenkins Pipeline DSL, который хранится в системе контроля версий.

---

#### Все ли Groovy фичи мне доступны в Jenkins pipeline? Могу ли я запретить опасные методы?
В Jenkins применяется не чистый Groovy, а его подмножество с различными ограничениями и надстройками. 
Например, можно создавать объекты, доступные в той JRE (Java-машине) которая у Вас установлена на сборочных узлах. 
Сам Jenkins тоже предоставляет дополнительные Java-классы, расширяя возможности своих Groovy-скриптов.
Но как из-за ограничений самого Jenkins, так и из целей безопасности доступ ко многим возможностям Java ограничен.

---

#### Что такое Jenkins Node и как они используются
Jenkins Node - это машина на которой выполняются сборки.

---

#### Могу ли я скрипт сборки хранить в Git
Да, можно.
![Pipeline from SCM](images/devops/pipiline-scm.png)

---

#### Про какие системы управления конфигурации слышал (ansible, puppet, chef)
ToDo: ответ

---

## Git
#### Зачем нужна система контроля версий?
Система контроля версий позволяет:
- отслеживать все изменения файлов исходного кода (историчность)
- изменять одни и те же файлы нескольким разработчикам одновременно
- при изменении одного и того-же фрагмента кода разными разработчиками позволяет разрешить конфликты слияния изменений
- иметь несколько версий исходного кода (ветвление)

---

#### Какие есть основные операции в Git?
- Создание репозитория: `git init`
- Добавление существующих файлов: `git add .`
- Клонирование: `git clone https://github.com/myrepo ./`
- Внесение изменений: `git commit -m "Commit message"`
- Создание и переход ветку:
    ```shell
    git branch new-feature
    git checkout new-feature
    ```
- Отправка изменений и приём изменений основной ветки
    ```shell
    git push origin
    git pull origin
    ```
- Слияние веток: `git merge new-feature` (замержит new-feature в текущую ветку)

---

#### Как появляются конфликты merge?
Конфликт возникает, когда в двух ветках была изменена одна и та же строка в файле или когда некий файл удален в одной ветке и отредактирован в другой.

---

#### Что такое gitflow?
Gitflow — модель ветвления Git. У нас есть две основные ветки: master и develop.
- В ветке master содержится ровно тот же код, что и в production версии проекта
- Вся работа делается в ветке develop.
- Во время работы на основе develop создаются так называемые feature-ветки. Их может быть неограниченное количество. 
- Далее, у нас есть ветка release, которая используется для подготовки к новому релизу проекта. 
- Наконец, есть ветка hotfix, которая служит для срочного исправления багов, найденных, например, на production.

![Gitflow](images/git/gitflow.png)

---

## Контейнеры и микросервисы
#### Зачем нужен Dockerfile?
Dockerfile — это инструкция для сборки образа. Это простой текстовый файл, содержащий по одной команде в каждой строке. 
В нем указываются все программы, зависимости и образы, которые нужны для разворачивания образа.

**Основные команды:**
- `FROM` — задаёт базовый (родительский) образ.
- `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ. 
- `ENV` — устанавливает постоянные переменные среды. 
- `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов. 
- `COPY` — копирует в контейнер файлы и папки. 
- `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы. 
- `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD. 
- `WORKDIR` — задаёт рабочую директорию для следующей инструкции. 
- `ARG` — задаёт переменные для передачи Docker во время сборки образа. 
- `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются. 
- `EXPOSE` — указывает на необходимость открыть порт. 
- `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.

---

#### Отличие виртуализации от контейнеризации
Ответ:

<details><summary markdown="span">Виртуализация и гипервизор (hypervisor)</summary>

Виртуализация - предоставление набора вычислительных ресурсов или их логического объединения, абстрагированное от 
аппаратной реализации, и обеспечивающее при этом логическую изоляцию друг от друга вычислительных процессов, 
выполняемых на одном физическом ресурсе.

Гипервизор (Hypervisor, он же virtual machine monitor / VMM / virtualizer) - это аппаратная схема (native/bare-metal 
hypervisor type 1), либо программа (hosted hypervisor type 2), обеспечивающая или позволяющая одновременное, 
параллельное выполнение нескольких операционных систем на одном и том же хост-компьютере посредством использования 
технологии виртуализации.

Гипервизор обеспечивает изоляцию операционных систем друг от друга, защиту и безопасность, разделение ресурсов 
между различными запущенными ОС и управление ресурсами.

Гипервизор также обязан предоставлять работающим под его управлением на одном хост-компьютере ОС средства связи и 
взаимодействия между собой (например, через обмен файлами или сетевые соединения) так, как если бы эти ОС 
выполнялись на разных физических компьютерах.

Гипервизор сам по себе в некотором роде является минимальной операционной системой (микроядром или наноядром).  
Он предоставляет запущенным под его управлением операционным системам службу виртуальной машины, виртуализируя или 
эмулируя реальное (физическое) аппаратное обеспечение конкретной машины.  
Управляет этими виртуальными машинами, выделением и освобождением ресурсов для них.  
Гипервизор позволяет независимое «включение», перезагрузку, «выключение» любой из виртуальных машин с той или иной ОС.  
При этом операционная система, работающая в виртуальной машине под управлением гипервизора, может, но не обязана «знать», 
что она выполняется в виртуальной машине, а не на реальном аппаратном обеспечении.

Среди гипервизоров аппаратного типа (native/bare-metal
[hypervisor type 1](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D0%B7%D0%BE%D1%80))
можно отметить следующие: VMware ESXi, Hyper-V, Xbox One system software.

Среди гипервизоров программного типа, т.е. работающих поверх ОС (hosted
[hypervisor type 2](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D0%B7%D0%BE%D1%80)),
можно отметить следующие: VirtualBox, Parallels Desktop for Mac, QEMU, VMware Player & Workstation.

![VM](images/microservices/hypervisor_types.png)

</details>

<details><summary markdown="span">Виртуальные машины (VM)</summary>

Виртуальные машины (VM) работают посредством технологии виртуализации, предоставляемой hypervisor.
Как следствие, каждая VM требует запуск собственной операционной системы (OS), а также виртуальной копии hardware,
которые необходимо OS для запуска и работы.

Операционная система и все приложение, запущенные в рамках одной VM, разделяют hardware ресурсы host'а (физического 
устройство, на котором запущена VM) с учетом квотирования ресурсов между VM на стороне hypervisor. 

![VM](images/microservices/vm.png)

К особенностям VM можно отнести следующие:
* возможность запуска любой операционной системы (OS);
* возможность запуска различных OS на одном host'е (физическом устройстве);
* обеспечивается высокий уровень безопасности относительно изоляции между собой несколько VM, запущенных на одном host'е;
* хорошо известная технология:
  * имеет множество надежных средств для управления и контроля уровня безопасности;
* куда более эффективная утилизация ресурсов по сравнению с управлением несколькими физическими устройствами:
  * влечет экономию средств.

</details>

<details><summary markdown="span">Контейнеры (Containers)</summary>

Контейнеры используют несколько иной уровень виртуализации.
Если в случае VM единицей виртуализации было hardware (создавать виртуальное физическое устройство), то в случае
контейнеров единицей виртуализации выступает операционная система.

Другими словами, если VM в качестве средства изоляции использовали hypervisor, то контейнеры поднимаются на уровень выше
и для изоляции используют средства host'ов ОС, поверх которой работают.

![containers](images/microservices/containers.png)

Контейнеры размещаются поверх физического сервера и его host'овой операционной системы.  
Каждый контейнер разделяет ядро host'овой операционной системы, а также, обычно, ряд библиотек.

Разделяемые компоненты являются read-only для контейнера.  
Контейнер получает изолированное, а в некоторых случаях виртуализированное, представление системы.  
Например, контейнер может обращаться к виртуализированной версии файловой системы и реестра, но любые изменения 
затрагивают только контейнер и удаляются при его остановке.  
Чтобы сохранить данные, контейнер может подключить постоянное хранилище, например общую папку (монтируемое устройство).

Контейнер собирается поверх ядра, но ядро не предоставляет все интерфейсы API и службы, необходимые для запуска 
приложения. Большинство из них предоставляются системными файлами (библиотеками), которые работают на уровне выше ядра в 
пользовательском режиме. Поскольку контейнер изолирован от среды пользовательского режима сервера, контейнеру требуется 
собственная копия этих системных файлов пользовательского режима, которые упаковываются в базовый образ.
Базовый образ выступает в качестве основного уровня, на котором собирается контейнер, предоставляя ему службы 
операционной системы, не предоставляемые ядром.

К наиболее популярным приложениям для работы с контейнерами, использующими OS-level virtualization можно отности:
* Docker;
* Podman;
* LXC (Linux Containers);
* systemd-nspawn;
* [Windows Containers](https://docs.microsoft.com/ru-ru/virtualization/windowscontainers/).

Рассмотрим средства изоляции различных ОС, на которых базируется работа вышеописанных приложений:

Linux:
* [cgroups](https://en.wikipedia.org/wiki/Cgroups):
  * группа процессов в Linux, для которой механизмами ядра наложена изоляция и установлены ограничения на некоторые 
  вычислительные ресурсы (процессорные, сетевые, ресурсы памяти, ресурсы ввода-вывода);
  * механизм позволяет образовывать иерархические группы процессов с заданными ресурсными свойствами и обеспечивает 
  программное управление ими;
* [namespaces](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE_%D0%B8%D0%BC%D1%91%D0%BD_(Linux)):
  * это функция ядра Linux, позволяющая изолировать и виртуализировать глобальные системные ресурсы множества процессов:
    * примеры ресурсов, которые можно виртуализировать:
      * ID процессов;
      * имена хостов;
      * ID пользователей;
      * доступ к сетям;
      * межпроцессное взаимодействие и файловые системы.

С недавних пор в Windows также появилась поддержка контейнеров, но технология проприетарна, поэтому детали неизвестны,
но вероятнее всего используются технологии аналогичные Linux cgroups и namespaces.
Подробнее см. [здесь](https://docs.microsoft.com/ru-ru/virtualization/windowscontainers/about/) и 
[здесь](https://habr.com/ru/post/465057/).

</details>

<details><summary markdown="span">VM vs Containers</summary>

Чем виртуальные машины отличаются от контейнеров?
Имеется ли смысл в использовании виртуальных машин вместо контейнеров в какой-либо ситуации?

Ответ:
Виртуальные машины могут использоваться вместо контейнеров в ситуации, когда:

Требуется:
* максимальный уровень изоляции с точки зрения безопасности
  (относительно других процессов, запущенных на том же hardware);
* максимальная оптимизация в коде приложения с учетом низкоуровневых особенностей операционной системы и hardware,
  в рамках которого запущено приложения.

Допускается:
* дополнительные затраты ресурсов (каждая VM довольно тяжеловесна, т.к. включает в себя всю
  операционную систему, включая её ядро);
* время старта измеримое в минутах (а не в миллисекундах, как в случае с контейнерами).

</details>

Подробнее см. [здесь](https://www.backblaze.com/blog/vm-vs-containers/).

---

#### Какие инструменты для оркестрации контейнеров использовали. Зачем они нужны?
OpenShift и Kubernetes:
- Мониторинг сервисов и распределение нагрузки Kubernetes может обнаружить контейнер, используя имя DNS или собственный IP-адрес. 
  Если трафик в контейнере высокий, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.
- Оркестрация хранилища Kubernetes позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.
- Автоматическое развертывание и откаты Используя Kubernetes можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. 
  Например, вы можете автоматизировать Kubernetes на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.
- Автоматическое распределение нагрузки Вы предоставляете Kubernetes кластер узлов, который он может использовать для запуска контейнерных задач. 
  Вы указываете Kubernetes, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.
- Самоконтроль Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.
- Управление конфиденциальной информацией и конфигурацией Kubernetes может хранить и управлять конфиденциальной информацией, такой как пароли, OAuth-токены и ключи SSH. 
  Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека.

---

#### Сколько запускается рутовых процессов если я на linux-машине разворачиваю 3 контейнера?
Запускается только базовый процесс Docker из под рута, контейнеры не плодят процессы из под рута.
```shell
root     27942  0.0  3.2 743316 32800 ?        Ssl   2021  98:15 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
```

---

#### Что такое Istio и зачем он нужен?
Istio — Open Source-проект, который решает сложности, возникающие в приложениях, основанных на микросервисной архитектуре 
и предлагает специализированное решение, полностью отделённое от сервисов и функционирующее путём вмешательства в сетевое взаимодействие. Таким образом реализует:
- Отказоустойчивость: опираясь на код статуса в ответе, оно понимает, произошёл ли сбой в запросе, и выполняет его повторно.
- Канареечные выкаты: перенаправляет на новую версию сервиса лишь фиксированное процентом число запросов.
- Мониторинг и метрики: за какое время сервис ответил?
- Трассировка и наблюдаемость: добавляет специальные заголовки в каждый запрос и выполняет их трассировку в кластере.
- Безопасность: извлекает JWT-токен, аутентифицирует и авторизует пользователей.

---

#### Что такое Service, Route, Pod?
- `Pod`: Pod это группа контейнеров с общими разделами, запускаемых как единое целое.
- `Service`: Сервис в Kubernetes это абстракция, которая определяет логический объединённый набор pod и политику доступа к ним.
- `Route (Ingress)`: Ресурс для добавления правил маршрутизации трафика из внешних источников в службы в кластере kubernetes. Выпускает сервис во внешнюю сеть путем выделения DNS имени.

---

#### Зачем нужен replica set?
`ReplicaSet` гарантирует, что определенное количество экземпляров подов будет запущено в кластере Kubernetes в любой момент времени.

---

#### У меня есть новая версия приложения, возможно с багами, я хочу только 10% нагрузки передать на новую версию, что мне делать?
Сделать можно с помощью Istio, для этого необходимо создать `VirtualService`:
```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: backend
  namespace: default
spec:
  gateways: []
  hosts:
  - "backend.default.svc.cluster.local"
  http:
  - match:
    - {}
    route:
    - destination:
        host: backend.default.svc.cluster.local
        subset: v1
        port:
          number: 80
      weight: 90 # 90% нагрузки
    - destination:
        host: backend.default.svc.cluster.local
        subset: v2
        port:
          number: 80
      weight: 10 # 10% нагрузки
```

---

#### Мне нужно закрыть обмен между микросервисами tls. Как я могу это реализовать?
С помощью Istio можно закрыть все взаимодействия mTLS, путем добавления `PeerAuthentication`:
```yaml
kind: PeerAuthentication
metadata:
  name: "default"
spec:
  mtls:
    mode: STRICT
```

---


## БД
#### Какие существуют нормальные формы?
- Первая нормальная форма (1NF) - Отношение находится в 1NF, если значения всех его атрибутов
атомарны (неделимы). 
- Вторая нормальная форма (2NF) - Отношение находится в 2NF, если оно находится в 1NF, и при
этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.
- Третья нормальная форма (3NF) - Отношение находится в 3NF, если оно находится в 2NF и все
неключевые атрибуты не зависят друг от друга.
- Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF) - Отношение находится в
BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в
качестве своего детерминанта некоторый потенциальный ключ.
- Четвёртая нормальная форма (4NF) - Отношение находится в 4NF , если оно находится в 3NF и
если в нем не содержатся независимые группы атрибутов, между которыми существует отношение
«многие-ко-многим».
- Пятая нормальная форма (5NF) - Отношение находится в 5NF, когда каждая нетривиальная зависимость 
соединения в ней определяется потенциальным ключом (ключами) этого отношения.
- Шестая нормальная форма (6NF) - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения, 
т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 
Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной 
формы для хронологической базы данных.
- Доменно-ключевая нормальная форма (DKNF) - Отношение находится в DKNF, когда каждое наложенное на неё 
ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.

---

#### Дайте определение терминам «простой», «составной», «потенциальный» и «альтернативный» ключ.
- **Простой** ключ состоит из одного атрибута (поля). 
- **Составной** - из двух и более. 
- **Потенциальный** ключ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных. 
При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись.
Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют **альтернативными**.

---

#### Какие существуют индексы?
Индекс — объект базы данных, создаваемый с целью повышения производительности выборки данных.

**По порядку сортировки**
- упорядоченные — индексы, в которых элементы упорядочены;
- возрастающие;
- убывающие;
- неупорядоченные — индексы, в которых элементы неупорядоченны.

**По источнику данных**
- индексы по представлению;
- индексы по выражениям.

**По воздействию на источник данных**
- кластерный индекс - при определении в наборе данных физическое расположение данных перестраивается 
  в соответствии со структурой индекса. Логическая структура набора данных в этом
  случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены,
  например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности 
  поиска данных даже по сравнению с обычными индексами. Увеличение производительности
  особенно заметно при работе с последовательными данными.
- некластерный индекс — наиболее типичные представители семейства индексов. В отличие от
  кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки 
  на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный
  индекс организует специальные указатели, включающие в себя: информацию об идентификационном 
  номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; 
  номер искомой записи на соответствующей странице; содержимое столбца.

**По структуре**
- B*-деревья; 
- B+-деревья; 
- B-деревья; 
- Хэши.

[Подробнее можно посмотреть здесь](https://github.com/enhorse/java-interview/blob/master/db.md#%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82)

---

#### Почему нельзя перегружать таблицу индексами?
Каждый индекс тратит дополнительное дисковое место, а также замедляет операции модификации данных.

---

#### Что такое транзакции?
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в
другое и выражаемое в изменении данных, хранящихся в базе данных.

**Свойства транзакций:**
- Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе
частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- Согласованность (consistency). Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, 
сохраняет согласованность базы данных.
- Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
- Долговечность (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) 
изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

---

#### Какие существуют уровни изоляции транзакций?
В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:

- Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read) — чтение не зафиксированных изменений как своей транзакции, 
так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате 
их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
- Чтение подтверждённых данных (read committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. 
Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.
- Повторяемость чтения (repeatable read, snapshot) — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями 
после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
- Упорядочиваемость (serializable) — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически 
эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.

---

#### Что такое фантомное чтение?
Фантомное чтение (phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. 
Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях 
выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.

---


ToDo: нужно добавить что-то по нерелеационным бд

## Сети

Для полноты понимания рекомендуется посмотреть обучающий [видео курс](https://www.youtube.com/watch?v=OLFA0soYGhw&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1).

#### Чем tcp отличается от udp?
Протоколы TCP и UDP находятся на транспортном уровне модели OSI, но имеют следующие различия:

TCP:
* `+` обеспечивает гарантию доставки;
* `+` обеспечивает сохранение порядка сообщений на стороне получателя;
* `-` имеет накладные расходы:
  * на создание соединения (доп запросы на установку и разрыв соединения с обеих сторон общения);
  * на доп заголовки (20 байт, необходимые для упорядочивания сообщений, отслеживания не полученных TCP сегментов, 
  управлением TCP окном и так далее):
    * особенно актуально, с учетом наличия доп запросов на установку соединения.

UDP:
* `+` не имеет накладных расходов:
  * имеет очень простое устройство, каждая UDP datagram содержит только следующие данные:
    * порт отправителя;
    * порт получателя;
    * длина UDP datagram;
    * контрольная сумма UDP datagram;
* `-` не обеспечивает гарантию доставки;
* `-` не обеспечивает сохранение порядка сообщений на стороне получателя.

Подробнее:
* сравнение см. в [видео уроке](https://www.youtube.com/watch?v=g7vq-JVId58&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1);
* обзор UDP см. в [видео уроке](https://www.youtube.com/watch?v=GBrLfZvRrd8&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1);
* обзор TCP см. в [видео уроке](https://www.youtube.com/watch?v=CKUOb4htnB4&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1).

---

#### Чем отличается Unicast / Multicast / Broadcast?
Ответ:
* unicast (юникаст) – процесс отправки пакета от одного хоста к другому хосту;
* multicast (мультикаст) – процесс отправки пакета от одного хоста к некоторой ограниченной группе хостов;
* broadcast (бродкаст) – процесс отправки пакета от одного хоста ко всем хостам в сети.
Эти 3 типа передачи данных используются для различных целей, давайте рассмотрим более подробно.

Подробнее см. [здесь](http://infocisco.ru/types_communication.html) или в рамках [видео урока](https://www.youtube.com/watch?v=hSnXwFE0dqU).

---

#### Уровни модели OSI и модели TCP/IP

![OSI vs TCP/IP](images/network/osi_vs_tcp-ip.png)

Подробнее см. [здесь](https://community.fs.com/ru/blog/tcpip-vs-osi-whats-the-difference-between-the-two-models.html),
либо в рамках кратких видео уроков по [модели OSI](https://www.youtube.com/watch?v=Tt8BTkxz_Vc&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1)
и [модели TCP/IP](https://www.youtube.com/watch?v=UZo4ffQ-aAc&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1).

---

#### Балансировщик имеет маркировку L4 и L7, какой мне нужно использовать если я хочу терминировать ssl трафик через балансировщик?
TLS/SSL относится к 6-му уровню модели OSI (presentation layer), как следствие, потребуется использование L7 балансировщика,
т.к. L4 "не поднимается" выше 4-го уровня модели OSI (transport layer).

---

#### Какие существуют способы указания длины тела сообщения
Ответ:
* посредством указания в заголовке Content-Length количества байт, которые следует прочитать после окончания заголовков 
(после пустой строки):
  * при этом тело сообщения может состоять как из одной единой части (в случае с Content-Type: application/*), 
  так и из нескольких (multipart/*), причем в случае наличия нескольких частей:
    * Content-Length на уровне заголовков всего сообщения указывает суммарную длину
      всех частей тела сообщения (включая разделители);
    * для разделения частей сообщения используются разделитель (который указывается в заголовке boundary);
* [посредством использования механизма chunked encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding):
  * указывается заголовок `Transfer-Encoding: chunked`;
  * тело сообщения разбивается на куски (chunk'и):
    * первая строка chunk - это длина данных этого chunk (в байтах), которые начинаются со следующей строки;
* посредством закрытия TCP соединения:
  * не удастся воспользоваться в ситуации, когда в рамках одного TCP соединения последовательно отправляется 
  несколько HTTP запросов.

Подробнее см. [здесь](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4).

---

#### Расскажите про TCP Back Pressure (он же TCP Sliding Window Flow Control)
Ответ: Протокол TCP используется механизм управления потоком пакетов под названием "скользящее окно" (sliding window).

Данный механизм используется для избежания "простоя" в интервалы между завершением отправки пакета и получением уведомления о его получении
(со стороны получателя), что обусловлено тем, что между отправкой и получением уведомления имеется некоторая задержка,
вызванная накладными расходами на передачу данных по всем звеньям сети (например, по маршрутизаторам).

Механизм базируется на идее отправки нескольких последовательных пакетов данных не дожидаясь уведомления от 
получателя (TCP ACK), вместо этого, ожидается получение одного уведомления, аккумулирующего информацию обо всех 
(или части) ранее отправленных TCP пакетах.

Количество пакетов, которые могут быть отправлены не дожидаясь ACK называются TCP окном (TCP window).

Окно называется "скользящим", т.к. оно как бы скользит (движется) по потоку данных, которые нужно передать.
Если было получено уведомление о получении N пакетов (ACK), то отправляются следующие N пакетов, т.е. окно "сдвигается" 
на следующую часть потока данных:

![TCP Window](images/network/tcp-window.png)

Back Pressure осуществляется за счет управления размером окна со стороны получателя:
* при отправке кумулятивного уведомления о получении TCP пакетов (ACK), в заголовке TCP ответа также указывается 
максимальное количество байт полезной нагрузки (payload), которое готов принять получатель:
  * значение заголовка рассчитывается на основании размера буфера данных:
    * поступающие по сети данные извлекаются из TCP сегментов и складываются в буфер;
    * объем свободного места в буфере и является размеров окна;
* данный заголовок должен прочитать отправитель и учесть его значение при расчете количества TCP сегментов, которые он
будет отправлять в рамках TCP окна, например:
  * если получатель в TCP ACK указал значение 10220, а на канальном уровне (модели OSI) используется сеть Ethernet 
  (где мо умолчанию максимальный размер кадра составляет 1500 байт, он же MTU), то максимальное количество пакетов, 
  которые отправителю имеет смысл отправлять можно рассчитать примерно следующим образом:
    * 10220 / 1460 == 7, пояснение:
      * 1460 - это MSS (Maximum TCP segment size), где
        * MSS = MTU - (TCP headers size + IP headers size), где
          * MTU (Maximum transmission unit) для Ethernet, по умолчанию, составляет 1500 байт;
          * TCP headers size == 20 байт;
          * IP headers size == 20 байт.

Если получателю будет отправлено больше данных, чем он готов сохранить в буфер, то он просто будет откидывать такие 
TCP сегменты.

![TCP Window Flow Control](images/network/tcp-window_flow-control.png)

Подробнее см. [здесь](https://blog.wallaroolabs.com/2018/04/how-the-end-to-end-back-pressure-mechanism-inside-wallaroo-works/) 
или в двух видео уроков:
1. [Sliding TCP Window](https://www.youtube.com/watch?v=hd6QNXK5rPk&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1);
2. [Flow Control Over Sliding TCP Window](https://www.youtube.com/watch?v=YCW4fLqFlME&list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1).

---

#### Что такое HTTP pipelining
Ответ: Особенность HTTP/1.1, позволяющая последовательно передавать несколько HTTP запросов в рамках одного TCP канала,
без ожидания ответа на них.

После завершения передачи всех HTTP запросов, начинается получение ответов, порядок которых должен соответствовать 
порядку отправки запросов.

![HTTP Pipelining](images/network/http_pipelining.png)

Подробнее см. [здесь](https://en.wikipedia.org/wiki/HTTP_pipelining) или в рамках [видео урока](https://youtu.be/7DitlqcesKI?list=PLtPJ9lKvJ4oiNMvYbOzCmWy6cRzYAh9B1&t=401).
[Пример использования](https://github.com/apache/httpcomponents-core/blob/5.0.x/httpcore5/src/test/java/org/apache/hc/core5/http/examples/AsyncPipelinedRequestExecutionExample.java).

---

#### Что такое TCP no delay или что такое алгоритма Нейгла (Nagle algorithm)
Ответ:
Это алгоритм буферизации отправляемых данных в рамках TCP пакета, являющийся средством повышения эффективности работы 
сетей TCP/IP, позволяющим уменьшить количество пакетов, которые должны быть отправлены по сети.

Он используется, когда размер отправляемых данных в рамках TCP пакета очень маленький, т.е. когда служебная информации
(например, TCP заголовки) по размеру сильно превышает полезную нагрузку (сами передаваемые данные).

Данный алгоритм скапливает данные в своем буфере до тех пор, пока не будет получено уведомление об успешно получении
предыдущего TCP пакета (TCP ACK).

![Nagle Algorithm](images/network/nagle_algorithm.png)

Параметр TCP_NODELAY используется для отключения данного механизма поведения.

Подробнее см. [здесь](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9D%D0%B5%D0%B9%D0%B3%D0%BB%D0%B0) 
или [здесь](https://stackoverflow.com/questions/3761276/when-should-i-use-tcp-nodelay-and-when-tcp-cork).

---

## Linux
#### Что такое рут и почему опасно сидеть под ним?
ToDo: ответ

---

#### Как убить процесс?
ToDo: ответ

---

#### Как отобразить содержимое каталога?
ToDo: ответ

---

#### Что за команда nohup?
ToDo: ответ

---

#### В чем смысл команды chmod +x file и chmod 777 file?
ToDo: ответ

---

#### Нужно посмотреть какие коннекты открыты до определенного хоста в настоящий момент. Как это сделать?
ToDo: ответ

---

#### Что такое crontab и для чего используется?
ToDo: ответ

---


## MQ, kafka
расскажите про kafka. Что используется для управления кластером кафки
как я могу получить splitBrain в кафке?
расскажите про zero copy. Какие есть требования к передаваемым данным, что бы мы могли ускорить передачу с использованием zero copy
что произойдет если продьюсер отправит данные в топик, который в кластере не существует (с настройками по умолчанию).
в топике несколько партиций. продьюсер пишет сразу во все. Как будет читать данные консумер?

работали ли с MQ.
что такое кластерная очередь?
если из одной очереди читает сразу много потребителей, как я могу обеспечить корректную работу очереди?
потребитель не умеет работать с заголовками, а нам нужно заголовки сохранить и вернуть скоррелированный и обогащенный заголовками ответ. Могу ли я это сделать?
расскажите в чем роль брокера? какие я на нем действия могу сделать?
мне нужно на одном менеджере разграничить права для разных потребителей (разные наборы очередей) и закрыть все это тлс. Умеет ли это WebSphrere MQ?

## процесс
работали ли в эджайле? расскажите есть ли у вас негативный или наоборот позитивный опыт
что такое спринт, история, эпик, таска?
кто решает что в спринт берет команда?
что должно быть итогом спринта?
что такое планирование и демо?