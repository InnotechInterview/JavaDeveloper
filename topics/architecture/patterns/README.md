### Паттерны проектирования/разработки

#### Какие существуют типы паттернов проектирования?

- Порождающие:
    - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов, например:
        - Singleton, Factory Method, Abstract Factory, Builder, Prototype;
- Структурные:
    - отвечают за построение удобных в поддержке иерархий классов, например:
        - Adapter, Bridge, Facade, Decorator, Composite, Proxy, Flyweight;
- Поведенческие:
    - решают задачи эффективного и безопасного взаимодействия между объектами программы, например:
        - Iterator, Observer, Strategy, Command, Mediator, State, Visitor, Template Method, Memento, Chain of Responsibility.

Подробнее см. [здесь](https://refactoring.guru/ru/design-patterns/catalog).

---

#### Чем отличается абстрактная фабрика от фабричного метода?

[Абстрактная фабрика](https://refactoring.guru/ru/design-patterns/abstract-factory) — это порождающий паттерн
проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам
создаваемых объектов.

[Фабричный метод](https://refactoring.guru/ru/design-patterns/factory-method) — это порождающий паттерн проектирования,
который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых
объектов.

Отличия:

- фабричный метод используется для создания только одного объекта, а абстрактная фабрика предназначена для создания
  семейств связанных или зависимых объектов:
    - например, отдельная фабрика UI объектов для Windows / Linux / Mac (предоставляет методы для создания: окна, кнопки,
      ...);
    - объекты, которые создает абстрактная фабрика, сами по себе, могут состоять из фабричных методов;
- абстрактная фабрика использует композицию для делегирования ответственности за создание объекта другому классу, в
  то время как фабричный метод использует наследование и опирается на производный класс или
  подкласс для создания объекта:
    - пример фабричного метода:
        - класс, в котором имеется абстрактный (или доступный для переопределения в наследниках) метод для создания
          экземпляров какого-либо объекта, при этом этот метод используется внутри этого же класса, а не предназначен для
          вызова за пределами иерархии наследования данного класса (например, другими классами, использующими данный в
          качестве композиции, т.е. хранящими у себя в поле), т.е. он сам же и является его потребителем (вот здесь и
          проявляется концепция переопределения поведения в создании объекта наследниками);
    - пример абстрактной фабрики:
        - класс, в котором имеется один и более абстрактный метод для создания экземпляров какого-либо объекта (или
          связанных типов объектов в случае нескольких методов), при этом экземпляры наследников этого класса (реализующих
          методы) используются в виде композиции (например, подтягиваются в виде зависимостей к Spring bean'ам через
          механизм DI).

Подробнее см. [здесь](https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns).

---

#### Почему Singleton считается анти-паттерном?

Главная проблема синглтона в том, что это первый паттерн описанный в GoF (Gang Of Four):

1. Синглтон нарушает SRP (Single Responsibility Principle) — класс синглтона, помимо того чтобы выполнять свои
   непосредственные обязанности, занимается еще и контролированием количества своих экземпляров (в отличие от фабрики).

2. Глобальное состояние. Про вред глобальных переменных вроде бы уже все знают, но тут та же самая проблема. Когда мы
   получаем доступ к экземпляру класса, мы не знаем текущее состояние этого класса, и кто и когда его менял, и это
   состояние может быть вовсе не таким, как ожидается. Иными словами, корректность работы с синглтоном зависит от
   порядка обращений к нему, что вызывает неявную зависимость подсистем друг от друга и, как следствие, серьезно
   усложняет разработку.

3. Зависимость обычного класса от синглтона не видна в публичном контракте класса. Так как обычно экземпляр синглтона не
   передается в параметрах метода, а получается напрямую, через GetInstance(), то для выявления зависимости класса от
   синглтона надо залезть в тело каждого метода — просто просмотреть публичный контракт объекта недостаточно.

4. Наличие синглтона понижает тестируемость приложения в целом и классов, которые используют синглтон, в частности.
   Во-первых, вместо синглтона нельзя подпихнуть Mock-объект, а во-вторых, если синглтон имеет интерфейс для изменения
   своего состояния, то тесты начинают зависеть друг от друга. Говоря же проще — синглтон повышает связность, и все
   вышеперечисленное, в том или ином виде, есть следствие повышения связности.

Подробнее см. [здесь](https://refactoring.guru/ru/design-patterns/singleton).

---

#### Назовите примеры паттернов которые недавно использовали и какие были задачи

---

#### Какие паттерны использует Spring?

**Dependency injection (в качестве реализации inversion of control (IOC))**

IoC-контейнер в Spring, отвечает за создание объекта, связывание объектов вместе, конфигурирование объектов и обработку
всего их жизненного цикла от создания до полного уничтожения. В контейнере Spring используется инъекция зависимостей
(Dependency Injection, DI) для управления компонентами приложения. Эти компоненты называются "Spring-бины" (Spring
Beans).

**Service Locator (Локатор служб)**

ServiceLocatorFactoryBean сохраняет информацию обо всех бинах в контексте. Когда клиентский код запрашивает сервис (бин)
по имени, он просто находит этот компонент в контексте и возвращает его. Клиентскому коду не нужно писать код, связанный
со Spring, чтобы найти бин.

Паттерн Service Locator используется, когда мы хотим найти различные сервисы, используя JNDI. Учитывая высокую стоимость
поиска сервисов в JNDI, Service Locator использует кеширование. При запросе сервиса первый раз Service Locator ищет его
в JNDI и кэширует объект. Дальнейший поиск этого же сервиса через Service Locator выполняется в кэше, что значительно
улучшает производительность приложения.

**Singleton (Одиночка)**

Паттерн Singleton гарантирует, что в памяти будет существовать только один экземпляр объекта, который будет
предоставлять сервисы.

В Spring область видимости бина (scope) по умолчанию равна singleton и IoC-контейнер создаёт ровно один экземпляр
объекта на Spring IoC-контейнер. Spring-контейнер будет хранить этот единственный экземпляр в кэше синглтон-бинов, и все
последующие запросы и ссылки для этого бина получат кэшированный объект.

Данная область видимости (singleton) обычно используется для бинов без состояния. Область видимости бина можно
определить как singleton или как prototype (создаётся новый экземпляр при каждом запросе бина).

Если не придираться к деталям, то можно сказать, что Spring также использует паттерн Singleton (Одиночка). Почему я
акцентирую на этом внимание? Потому, что референсная реализация singleton предполагает, что объект сам контролирует
создание своего экземпляра посредством статического метода `getInstance()`, в то время как Spring поступает иначе, ведь
он использует IoC-контейнер для этих целей (он контролирует создание и жизненный цикл всех бинов).

**Observer-Observable (Наблюдатель)**

Используется в механизме событий `ApplicationContext`. Определяет зависимость "один-ко-многим" между объектами, чтобы
при изменении состояния одного объекта все его подписчики уведомлялись и обновлялись автоматически.

**Factory (Фабрика)**

Этот паттерн позволяет инициализировать объект через публичный статический метод, называемый фабричным методом. Spring
использует паттерн Factory для создания объекта бина с использованием следующих двух подходов.

Такой подход, обычно, используется при создании бинов декларативно посредством XML конфигурации (а не аннотаций):

```xml
<bean id="someBean" class="ru.example.SomeBean" factory-method="create"/>
```

```java
public class SomeBean {
  public static SomeBean create() {
    return new SomeBean();
  }
}
```

**Proxy (Заместитель)**

Паттерн Proxy широко используется в AOP и remoting.

Пример использования:
- генерация наследника (через cglib или Java Dynamic Proxy) класса для оборачивания методов, помеченных аннотацией
  `@Transactional` в транзакции (init транзакции перед вызовом метода и commit после выхода из него).

Подробнее см. [здесь](https://habr.com/ru/company/otus/blog/451516/).

#### Какие вы знаете способы реализации pattern Singleton в java?

<details><summary markdown="span">By static method</summary>

```java
public class Singleton {
  private static volatile Singleton instance;

  public static Singleton getInstance() {
    if (instance == null) { // double checked locking для оптимизации
      synchronized (Singleton.class) {
        if (instance == null) {
          instance = new Singleton();
        }
      }
    }
    return instance;
  }

  private Singleton() {
  }
}
```

Особенности:
- `+` возможность работы с runtime ресурсами:
    - например, присутствует возможность передачи spring bean в аргументах конструктора;
- `+` возможность получения ранее созданного экземпляра Singleton.

</details>

<details><summary markdown="span">By initialize on demand holder idiom</summary>

```java
public class Singleton {
  private static class LazyHolder {
    private static final Singleton INSTANCE = new Singleton();
  }

  public static Singleton getInstance() {
    return LazyHolder.INSTANCE;
  }

  private Singleton() {
  }
}
```

Особенности:
- `+` возможность получения ранее созданного экземпляра Singleton;
- `-` отсутствие возможности работы с runtime ресурсами:
    - например, отсутствует возможность передачи spring bean в аргументах конструктора.

</details>

<details><summary markdown="span">By enum</summary>

```java
public enum Singleton {
  INSTANCE
}
```

Особенности:
- `+` возможность получения ранее созданного экземпляра Singleton;
- `-` отсутствие возможности работы с runtime ресурсами:
    - например, отсутствует возможность передачи spring bean в аргументах конструктора.

</details>

<details><summary markdown="span">By constructor</summary>

Возможно, данную реализацию не стоит даже считать Singleton, т.к. она лишь занимается контролем количества созданных
экземпляров, но не предоставляет возможность как-то получить ранее созданный экземпляр, но в образовательных целям мы
её рассмотрим:

```java
public class Singleton {
    private static volatile boolean alreadyExist;

    public Singleton() {
        if (!alreadyExist) { // double checked locking для оптимизации
            synchronized (Singleton.class) {
                if (alreadyExist) {
                    throw new IllegalArgumentException();
                }
                alreadyExist = true;
            }
        }
    }
}
```

Особенности:
- `+` возможность работы с runtime ресурсами:
    - например, присутствует возможность передачи spring bean в аргументы конструктора;
- `-` отсутствие возможности получения ранее созданного экземпляра Singleton.

</details>

---