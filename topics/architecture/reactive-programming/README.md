### Reactive programming

#### Расскажите что такое проблема 10к и как реактивное программирование позволяет ее решить

C10k (10k connections — проблема 10 тысяч соединений) — условное название задачи конфигурирования и обслуживания
высокопроизводительного сервера, способного обслуживать порядка 10 тыс. соединений одновременно.

<details><summary markdown="span">История</summary>

Возникло в 1999 году в рамках задачи обслуживания популярного в то время публичного FTP-сервера Simtel, его
администратор Ден Кегель обратил внимание, что обслуживающий узел на гигабитном канале по аппаратным показателям должен
был бы справляться с нагрузкой в 10 тыс. соединений, но программное обеспечение этого не позволяло.

По состоянию на середину 2010-х годов серверный аппаратный узел среднего уровня способен обрабатывать до 10 млн
соединений, в связи с чем появились требования к программному обеспечению обеспечивать соответствующий уровень
производительности по количеству одновременных подключений, обозначаемые как C10M.

Другими словами, в современных реалиях это уже совсем не проблема 10 тысяч соединений, а проблема 10 млн соединений.

</details>

<details><summary markdown="span">Синхронный сервер приложений</summary>

В рамках привычного синхронного сервера приложений (Tomcat / Undertow / ...) для поддержания каждого TCP connection
выделяется отдельный поток, в рамках которого полностью обрабатывается HTTP запрос (приема / обработка с учетом
обращений к БД или внешним сервисам / отправка ответа), что имеет следующие последствия для таких объемов трафика:

- большое количество потребляемых ресурсов ОЗУ:
    - каждый поток имеет свой stack (область ОЗУ, выделенная под поток и содержащая список элементов (стек вызовов / stack
      frames), организованных по принципу LIFO (Last In First Out)):
        - по умолчанию, в большинстве JVM размер stack составляет 512 KiB, т.е. для поддержания 10 тысяч потоков (это еще не
          считая служебных) потребуется 5 GiB памяти;
- накладные расходы на очень частое переключение контекста для ядер процессора (при переключении каждого ядра ЦПУ между
  потоками шедурером (планировщиком) операционной системы);

</details>

<details><summary markdown="span">Асинхронный сервер приложений</summary>

В рамках асинхронных серверов приложений (Netty и frameworks над ним, например, Spring WebFlux) работа, обычно,
представлена в рамках парадигмы реактивного программирования.

<details><summary markdown="span">Reactive programming (реактивное программирование)</summary>

По своей сути, реактивное программирование - это модель разработки, построенная поверх асинхронных потоков данных.

При использовании реактивного программирования потоки данных станут основой вашего приложения. События, сообщения,
вызовы и даже сбои будут передаваться в виде потока данных. При реактивном программировании вы "наблюдаете/следите" за
этими потоками и реагируете, когда значение в потоке изменяется (что и является основной причиной получаения названия
"реактивное программирование").

Потоки данных ("наблюдаемые объекты") бывают двух типов:
- cold (холодные):
    - потоки данного типа не выполняют никаких действий до тех пор, пока на него отсутствуют подписчики (Subscribers),
      запрашивающие данные (создающие back pressure):
        - другими словами, поток представляет собой асинхронное действие, которое не будет исполняться до тех пор, пока
          никто не заинтересован в получении результата (т.е. явно не запрашивает результат);
        - например, если представить чтение файла с диска для передачи его клиенту в виде cold stream, то очередная порция
          байт не будет вычитана до тех пор, пока на уровне TCP пакета не будет получено уведомление о получении предыдущей
          порции данных в рамках TCP window (подробнее см. вопрос про TCP back pressure);
- hot (горячие):
    - горячие потоки активируются вне зависимости от наличия подписчиков:
        - данные независимы от отдельно взятого подписчика: когда Subscriber подписывается на данные такого потока, то он
          получит все данные сгенерированные потоком уже после его подписки.

Подробнее см. [здесь](https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming) или
[здесь](https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape).

</details>

Если говорить о вариантах реализации парадигмы реактивного программирования, то обычно используется ограниченный
небольшой thread pool (например, равный количеству ядер процессора), потоки которого занимаются обработкой данных
на разных этапах stream'а (в общем случае, на каждом этапе стрима могут использоваться различные thread pool'ы).

Другими словами, вне зависимости от поступающей на сервер нагрузки всегда используется небольшой набор потоков, который
занимается обработкой данных на разных этапах stream'а при появлении back pressure (запросом данных в конце stream'а).

Реактивное программирование не увеличивает скорость обработки данных (относительно синхронного стиля обработки), оно
лишь призвано увеличить пропускную способность посредством оптимизации использования ресурсов (потоков и механизма их
обработки запросов, т.е. в данной парадигме - это механизм работы с потоком данных).

</details>

#### Почему получить DDoS легче именно при использовании реактивного программирования

Потому что, по умолчанию, он никак не ограничивает количество поступающих на обработку запросов, в отличие от
синхронного сервера, у которого в качестве ограничения может выступать заранее выделенный Thread Pool определенного
размера (конфигурируемый лимит в количестве потоков на обработку, ведь для обработки каждого запроса требуется
использовать отдельный поток).

Пояснение: При реактивном программировании можно взять в обработку ограниченное лишь ОЗУ количество запросов, но:
- упасть из-за OutOfMemory;
- получить эффект "бутылишного горлышка" на одном из участков потока:
    - например, если где-то перед этим используется hot stream (т.е. стрим, который активируется вне зависимости от
      подписчиков на него, т.е. не зависит от back pressure), который слишком сильно нагружает последующую часть стрима
      (обработка на разных этапах потока может иметь различную сложность и трудозатратность).

#### Можно ли анализировать ошибки по стектрейсу в реактивном приложении

Если говорить про Spring WebFlux, то возможно при использовании `.checkpoint()` в интересующих нас местах потока данных.

#### У меня небольшой веб сервер со сложной логикой на бэке. Запрос в среднем занимает 100мс. При нагрузке 1к запросов в секунду есть ли мне смысл переписывать свое приложение под реакт?

Если учесть, что обработка запроса занимает 100мс (0.1 сек), а среднее количество запросов в секунду 1000, то в среднем
одновременно на сервере исполняется 1000 * 0.1 = 100 запросов, т.е. в рамках синхронного сервера приложений параллельно
работает около 100 потоков, обрабатывающих запросы.

С такой нагрузкой и любой приличный синхронный сервер приложений должен справляться без проблем.

#### Существует ли у Spring модуль для реактива?
Spring WebFlux.

Реализуются интерфейсы reactive streams (Publisher / Subscriber и их комбинации).

#### Что общего у SEDA архитектуры и Akka

Обеспечение высокого уровня конкурентности, при этом изолируя вас от работы с многопоточностью.
Изоляция от работы с многопоточностью реализуется посредством использования концепций Event-Driven Architecture.

Обе концепции реализуют высокий уровень конкурентности посредством разбиения процесса обработки на шаги, каждый из
которых обрабатывает поступающие в него данные (или сигналы), генерируя новые данные (или сигналы), которые поступают
на следующий этап обработки используя те или иные "каналы" для передачи данных (или сигналов) между этапов (т.е. между
обработчиками, связанными с этапами).

SEDA реализует данный подход посредством:
- выделения каждого этапа в отдельный микросервис;
- выстраивания микросервисы в последовательную цепочку, между каждым из которых имеется асинхронный канал общения,
  представленный в виде Broker'а сообщений (например, Kafka / JMS).

Akka реализует данный подход посредством использования [модели акторов](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2)
в рамках одного приложения:
- выделяются объекты (акторы), считающиеся универсальным примитивом параллельного исполнения;
- актор в данной модели взаимодействует путём передачи сообщений с другими акторами;
- актор в ответ на получаемые сообщения может принимать локальные решения:
    - создавать новые акторы;
    - посылать свои сообщения;
    - устанавливать, как следует реагировать на последующие сообщения.