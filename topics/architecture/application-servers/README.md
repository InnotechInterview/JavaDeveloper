## Сервера приложений

#### Чем сервер приложений отличается от web сервера?
Web-сервер - это разновидность (подмножество) сервера приложений.

|     | Web-сервер | Сервер приложений |
| --- | :--------: | :---------------: |
| Включает в себя | только контейнер сервлетов | контейнер сервлетов + контейнер EJB (Enterprise JavaBeans) |
| Типы контента | статический контент | динамический контент |
| Расход ресурсов | меньше  | больше |
| Организует среду выполнения | для веб-приложений  | для корпоративных приложений |
| Многопоточность  | не поддерживается  | поддерживается  |
| Мощность | ниже  | выше |
| Протоколы | HTML и HTTP  | GUI, HTTP и RPC / RMI |
| Примеры реализаций | Nginx, Apache Tomcat | IBM WebSphere, Glassfish |

---

#### Какие упрощения для приложения предоставляет app server?
ToDo: ответ

---

#### Вам нужно настроить TLS в вашем приложении. Какие есть способы реализации этого, если приложение установлено не standalone?
ToDo: ответ

---

#### Чем отличается jar от war?

|     |  JAR  |  WAR  |
| --- | :--- | :--- |
| Расшифровка | Java Archive | Web Archive |
| Содержит | общие библиотеки классов Java, ресурсы, вспомогательные файлы и т. д. | jar-ы с реализацией, JSP, статические файлы фронт-энда, и мета-информацию для сервлет-контейнера (web.xml) |
| Структура архива | любая | предопределенная - с каталогами WEB-INF и META-INF |
| Расширение | `.jar` | `.war`  |
| Запуск | возможность запуска из командной строки | необходим сервер |
| Использование | в качестве библиотеки, плагина или любого приложения | в качестве веб-приложения |

---

#### Зачем нужен в общем случае кластер WAS? могу ли я использовать кластер для распределения нагрузки?
ToDo: ответ

#### Какие существуют способы авторизации клиента в рамках сессии HTTP(s) запросов?

<details><summary markdown="span">Send login + password every request</summary>

Клиентская сторона (например, браузер):
- каждый запрос обогащать логиной и паролем (или hash от пароля).

Серверная сторона:
- при получении запроса производить авторизацию на основании логина и пароля:
    - сравнить логин и пароль с имеющимися данными из БД:
        - в БД не рекомендуется хранить пароль в чистом виде во избежание утечек данных;
    - проверять наличие прав на выполнение запрошенной в рамках HTTP request операции на основании данных из БД;
- в случае успешной авторизации выполнять запрошенную операцию.

</details>

<details><summary markdown="span">Session cookies</summary>

Перед началом обработки запросов от клиента выполнить его авторизацию, например:
- заставить ввести клиента пару логин и пароль (либо hash от пароля);
- сравнить с имеющимися данными из БД:
    - в БД не рекомендуется хранить пароль в чистом виде во избежание утечек данных;
- сгенерировать token, который будет идентифицировать клиента в течение n минут:
    - сохранить token в in-memory хранилище на сервере приложений;
    - вернуть token в ответе на запрос авторизации в виде cookie.

Клиентское устройство (например, браузер):
- принимает cookie, сохраняет его во временное in-memory хранилище процесса:
    - ассоциируя его с доменным именем, откуда была получена cookie (согласно информации из cookie);
- обогащает этой cookie каждый последующий запрос.

Сервер приложений:
- при получении запроса сначала проверяет token из cookie на наличие в своем in-memory хранилище;
- проверяет наличие прав у клиента на выполнение запрошенной в HTTP request операции согласно данным из БД.

Ссылки:
- [session cookie](https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies#%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5_cookie).

</details>

<details><summary markdown="span">JWT (JSON Web Token)</summary>

Перед началом обработки запросов от клиента выполнить его авторизацию, например:
- заставить ввести клиента пару логин и пароль (либо hash от пароля);
- сравнить с имеющимися данными из БД (в БД не рекомендуется хранить пароль в чистом виде во избежание утечек
  данных);
- сгенерировать token, который будет авторизовывать клиента в течение n минут:
    - сохранить token в in-memory хранилище на сервере приложений;
    - вернуть token в ответе на запрос авторизации в виде cookie.

Особенность такого авторизующего token:
- содержит также информацию о правах пользователя;
- вся информация, содержащаяся в токене подписана приватным ключом пользователя.

Клиентское устройство (например, браузер):
- принимает cookie, сохраняет его во временное in-memory хранилище процесса:
    - ассоциируя его с доменным именем, откуда была получена cookie (согласно информации из cookie);
- обогащает этой cookie каждый последующий запрос.

Сервер приложений:
- при получении запроса сначала проверяет token на наличие в своем in-memory хранилище;
- проверяет валидной подписи в token:
    - если подпись валидна, то для определения наличия у пользователя прав на выполнение запрошенной в рамках HTTP request
      операции использует схему прав пользователя.

[JWT vs session cookie](https://stackoverflow.com/questions/43452896/authentication-jwt-usage-vs-session):
- это просто альтернативный способ поддержания сессий:
    - при использовании session cookie сессии поддерживаются на стороне сервера (server-side sessions):
        - `-` наличие узкого места в виде credential storage (БД / in-memory);
    - при использовании JWT сессии поддерживаются на стороне клиента (client-side sessions):
        - `-` безопасное хранение token на клиентской стороне;
        - `-` сложности в инвалидации JWT token'ов.

Ссылки:
- [RFC7519](https://tools.ietf.org/html/rfc7519);
- [обзор технологии](https://jwt.io/introduction);
- [tokens-vs-sessions](https://www.baeldung.com/cs/tokens-vs-sessions).

</details>

<details><summary markdown="span">Signature every request</summary>

Клиентская сторона (например, браузер):
- каждый запрос обогащать подписью:
    - рассчитывать digest (результат работы hash-функции) от содержимого запроса;
    - шифровать digest секретным ключом:
        - сгенерировать ключ на основании пароля (например,
          [посредством PBKDF2](https://www.baeldung.com/java-password-hashing#2-implementing-pbkdf2-in-java)).

Серверная сторона:

- при получении запроса валидировать подпись:
    1. рассчитывать digest (результат работы hash-функции) от содержимого запроса:
        - при расчете должна использоваться та же hash-функция, что и была использована на клиентской стороне (например,
          SHA256);
    2. дешифровать подпись из запроса секретным ключом:
    - сгенерировать ключ на основании пароля тем же способом, который был использован на клиентской стороне (например,
      [посредством PBKDF2](https://www.baeldung.com/java-password-hashing#2-implementing-pbkdf2-in-java)):
        - пароль извлечь из БД;
    3. проверить на равенство два digest: рассчитанный сервером и полученный в результате дешифрования подписи из запроса;

</details>