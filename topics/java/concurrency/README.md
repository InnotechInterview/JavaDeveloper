### Concurrency

Краткое изложение основных моментов можно найти [здесь](https://habr.com/ru/company/otus/blog/353414/).

#### Расскажите про принципы happens before

В JMM (java memory model) существует отношение happens before («Выполняется прежде») - отношение строгого частичного
порядка, введённое между атомарными командами (++ и -- не атомарны), придуманное не означающее «физически прежде».
Оно значит, что вторая команда будет «в курсе» изменений, проведённых первой.

Согласно этому отношению:

Синхронизация и мониторы:
- Захват монитора (начало synchronized, метод lock) и всё, что после него в том же потоке.
- Возврат монитора (конец synchronized, метод unlock) и всё, что перед ним в том же потоке.
    - Таким образом, оптимизатор может заносить строки в синхроблок, но не наружу.
- Возврат монитора и последующий захват другим потоком.

Чтение и запись:
- Любые зависимости по данным (то есть запись в любую переменную и последующее чтение её же) в одном потоке.
- Всё, что в том же потоке перед записью в volatile-переменную, и сама запись.
- volatile-чтение и всё, что после него в том же потоке.
- Запись в volatile-переменную и последующее считывание её же.
    - Таким образом, volatile-запись делает с памятью то же, что возврат монитора, а чтение — то же, что захват. А значит:
      если один поток записал в volatile-переменную, а второй обнаружил это, всё, что предшествует записи, выполняется
      раньше всего, что идёт после чтения; см. иллюстрацию.
    - Для объектных переменных (например, `volatile List x;`) столь сильные гарантии выполняются для ссылки на объект, но
      не для его содержимого.

Обслуживание объекта:
- Статическая инициализация и любые действия с любыми экземплярами объектов.
- Запись в final-поля в конструкторе и всё, что после конструктора. Как исключение из всеобщей транзитивности, это
  соотношение happens-before не соединяется транзитивно с другими правилами и поэтому может вызвать межпоточную гонку.
- Любая работа с объектом и finalize().

Обслуживание потока:
- Запуск потока и любой код в потоке.
- Зануление переменных, относящихся к потоку, и любой код в потоке.
- Код в потоке и join(); код в потоке и isAlive() == false.
    - interrupt() потока и обнаружение факта останова.

![Happens Before](se/images/concurrency/happens-before.png)

---

#### Как я могу создать поток?

Существует два способа создать поток, оба из которых базируются на оперировании классом `java.lang.Thread`.

<details><summary markdown="span">Использование Runnable</summary>

```java
// создаем экземпляр потока, передавая ему в качестве аргумента конструктора реализацию Runnable(), в методе run() которого находится наш код
// (поток на уровне ОС еще пока не создается и не запускается)
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // some code
    }
});
        
// стартуем поток (будет выделен поток в ОС, и уже в рамках него вызван метод Runnable#run())
thread.start();
```

</details>

<details><summary markdown="span">Переопределение метода Thread.run()</summary>

```java
// создаем экземпляр класса наследника Thread, переопределяя у него метод run(), в который помещаем наш код
// (поток на уровне ОС еще пока не создается и не запускается)
Thread thread = new Thread() {
    @Override
    public void run() {
        // some code
    }
};

// стартуем поток (будет выделен поток в ОС, и уже в рамках него вызван метод Runnable#run())
thread.start();
```

</details>

---

#### Что такое race condition и thread-safe?

<details><summary markdown="span">Race condition</summary>

Состояние гонки (англ. race condition), также конкуренция — ошибка проектирования многопоточной системы или
приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Race condition происходит, когда два или более потока обращаются к общим ресурсам и пытаются их изменить одновременно.

В связи с тем, что планировщик потоков ОС (thread scheduler) может переключаться между потоками в любой момент времени,
то вы не знаете в каком порядке каждый из потоков будет обращаться к общим данным. Как следствие, результат изменения
данных будет зависеть от алгоритма планировщика потоков ОС.

Другими словами, потоки "соревнуются" (racing) за доступ и изменение данных.

Проблема обычно происходит, когда один поток выполняет над общими данными "check-then-act" (сначала проверяет значение
таких данных, а затем изменяет его в зависимости от него), а в это время другой поток выполняет какое-то действие
над этими данными в промежутке между "check" и "act", например:

```java
if (x == 5) // The "Check"
{
   y = x * 2; // The "Act"

   // If another thread changed x in between "if (x == 5)" and "y = x * 2" above,
   // y will not be equal to 10.
}
```

Самый простой способ для предотвращения race condition в такой ситуации - это, например, выстраивание блокировки вокруг
всего блока "check-then-act":

```java
// Obtain lock for x
if (x == 5)
{
   y = x * 2; // Now, nothing can change x until the lock is released. 
   // Therefore y = 10
}
// release lock for x
```

</details>

<details><summary markdown="span">Thread-safety</summary>

Потоковая безопасность (англ. thread-safety) — это концепция программирования, применимая к многопоточным программам.
Код потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно.

Это означает, что разные потоки могут обращаться к одним и тем же ресурсам без выявления ошибочного поведения или
получения непредсказуемых результатов.

Давайте рассмотрим основные подходы, которые позволяют достигнуть потоко-безопасности.

<details><summary markdown="span">Stateless Implementations</summary>

В большинстве случаев ошибки в многопоточных приложениях являются результатом неправильного разделения состояния между
несколькими потоками.

Поэтому первый подход, заключается в обеспечении потоко-безопасности с помощью реализаций без сохранения состояния.

Чтобы лучше понять этот подход, давайте рассмотрим простой служебный класс со статическим методом, вычисляющим факториал
числа:

```java
public class MathUtils {
    public static BigInteger factorial(int number) {
        BigInteger f = new BigInteger("1");
        for (int i = 2; i <= number; i++) {
            f = f.multiply(BigInteger.valueOf(i));
        }
        return f;
    }
}
```

Какие особенности мы наблюдаем:
- метод не сохраняет/изменяет состояние;
- метод не полагается на внешнее состояние.

Как следствие, метод является идемпонетным (на одни и те же входные данные, он всегда возвращает одни и те же
результаты).

Все потоки могут безопасно вызывать метод factorial() и получать ожидаемый результат, не мешая друг другу и не изменяя
выходные данные, генерируемые методом для других потоков.

Следовательно, реализации без сохранения состояния — это самый простой способ обеспечить потокобезопасность.

</details>

<details><summary markdown="span">Immutable Implementations</summary>

Если нам нужно разделить состояние между разными потоками, мы можем создать потоко-безопасные классы, сделав их
состояние неизменяемым. Экземпляр класса является неизменяем, если его внутреннее состояние не может быть изменено после
его создания.

Самый простой способ создать неизменяемый класс в Java - объявить все поля private final и не предоставлять сеттеры:

```java
public class MessageService {
    private final String message;

    public MessageService(String message) {
        this.message = message;
    }
    
    // standard getter
}
```

Так как состояние экземпляра класса не может быть изменено после его создания, то такая реализация является
потоко-безопасной.

</details>

<details><summary markdown="span">Thread-Local Fields</summary>

Если нам в действительности нужно поддерживать состояние объекта, мы можем создать потоко-безопасные классы, которые не
разделяют состояние между потоками, сделав их поля локальными для потока.

Мы можем легко создавать классы, поля которых являются thread-local (определены в виде private полей у класса Thread).

```java
public class StateHolder {
    private final String state;
    // standard constructors / getter
}

// вариант 1: посредством использования private поля у экземпляра класса Thread
public class MyThread extends Thread {
  public static final StateHolder statePerThread =  new StateHolder("active");
}

// вариант 2: посредством использования готового класса ThreadLocal (делает примерно тоже самое)
public class ThreadState {
  public static final ThreadLocal<StateHolder> statePerThread = new ThreadLocal<StateHolder>() {
    @Override
    protected StateHolder initialValue() {
      return new StateHolder("active");
    }
  };

  public static StateHolder getState() {
    return statePerThread.get();
  }
}
```

Thread-local поля очень похожи на обычные поля класса, за исключением того, что каждый поток, который обращается к
ним через getter/setter, получает независимо инициализированную копию поля, так что каждый поток имеет свое собственное
состояние.

</details>

<details><summary markdown="span">Synchronized Methods & Statements</summary>

**Synchronized Methods**

Если нам требуется, чтобы только один поток могу получить доступ к методу одновременно, блокируя доступ к этому методу
из других потоков, то можно воспользоваться модификатором метода - `synchronized`. Другие потоки останутся
заблокированными до тех пор, пока не завершится первый поток или пока метод не вызовет исключение.

Например, таким образом мы можем создать потоко-безопасную версию `incrementCounter()`:

```java
public synchronized void incrementCounter() {
    counter += 1;
}
```

Так как один поток за раз может получить доступ к `synchronized` методу, один поток будет выполнять метод
`incrementCounter()`, а другие, в свою очередь, будут делать то же самое. Никакого перекрывающегося выполнения не
произойдет.

`synchronized` методы основаны на использовании «внутренних блокировок» или «блокировок монитора». Внутренняя
блокировка - это неявный внутренний объект, связанный с конкретным экземпляром класса.

В многопоточном контексте термин «монитор» — это просто ссылка на экземпляр объекта, используемый в качестве сущности,
к которой привязывается блокировка, обеспечивая монопольный доступ к набору указанных методов или операторов,
заключенных в рамки конструкции синхронизации.

Когда поток вызывает `synchronized` метод, он выполняет блокировк (захватывает монитор). После того, как поток завершает
выполнение метода, он освобождает блокировку (отпускает монитор), позволяя другим потокам получить блокировку и доступ к
методу.

Мы можем реализовать синхронизацию в методах экземпляра класса, статических методах класса и операторах (см. далее
synchronized statements).

**Synchronized Statements**

Иногда синхронизация всего метода может быть излишней, если нам просто нужно сделать сегмент метода потокобезопасным.
Синхронизация стоит дорого, поэтому выгоднее синхронизировать только соответствующие части метода.

Чтобы проиллюстрировать этот вариант использования, давайте несколько изменим метод `incrementCounter()`:

```java
public void incrementCounter() {
    // additional unsynced operations
    synchronized(this) {
        counter += 1; 
    }
}
```

В отличие от синхронизированных методов, синхронизированные операторы должны указывать объект, обеспечивающий встроенную
блокировку. В пример выше используется ссылка на текущий объект класса (`this`).

Мы можем немного улучшить потокобезопасную реализацию класса `Counter`, используя вместо этого другой объект в качестве
блокировки монитора:

```java
public class ObjectLockCounter {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void incrementCounter() {
        synchronized(lock) {
            counter += 1;
        }
    }
    
    // standard getter
}
```

Мы используем ничего не делающий экземпляр класса `Object` в качестве монитора, т.е. для построения блокировки поверх
него.

**Предостережения**

Несмотря на то, что мы можем использовать любой объект Java в качестве встроенной блокировки, следует избегать
использования String для целей блокировки:

```java
public class Class1 {
    private static final String LOCK  = "Lock";

    // uses the LOCK as the intrinsic lock
}

public class Class2 {
    private static final String LOCK  = "Lock";

    // uses the LOCK as the intrinsic lock
}
```

На первый взгляд кажется, что эти два класса используют в качестве блокировки два разных объекта. Однако из-за эффекта
оптимизирующего работу со строками, интернирования строк (String interning), эти два значения `Lock` могут на самом
деле ссылаться на один и тот же объект в пуле строк. То есть `Class1` и `Class2` используют одну и ту же блокировку.

Это, в свою очередь, может привести к неожиданному поведению в параллельных контекстах.

В дополнение к `String` мы должны избегать использования каких-либо кэшируемых или повторно используемых объектов в
качестве мониторов для блокировок. Например, метод `Integer.valueOf()` кэширует небольшие числа (на отрезке от `-128`
до `127`). Поэтому вызов
`Integer.valueOf(1)` возвращает один и тот же объект даже в разных классах.

</details>

<details><summary markdown="span">Locks</summary>

**Reentrant Lock**

Java предоставляет улучшенный набор реализаций блокировки, чье поведение несколько сложнее, чем встроенные блокировки,
рассмотренные выше.

Со встроенными блокировками (см. `synchronized`) модель получения блокировки довольно жесткая: один поток получает
блокировку, затем выполняет метод или блок кода и, наконец, снимает блокировку, чтобы другие потоки могли получить ее и
получить доступ к методу.

Нет базового механизма, который проверяет потоки в очереди и предоставляет приоритетный доступ к потокам с наибольшим
временем ожидания. Экземпляры `ReentrantLock` позволяют нам делать именно это, тем самым предотвращая нехватку ресурсов у
потоков в очереди:

```java
public class ReentrantLockCounter {
    private int counter;
    private final ReentrantLock reLock = new ReentrantLock(true);
    
    public void incrementCounter() {
        reLock.lock();
        try {
            counter += 1;
        } finally {
            reLock.unlock();
        }
    }
    
    // standard constructors / getter
}
```

Конструктор `ReentrantLock` принимает необязательный логический параметр `fairness` (справедливая блокировка). Если
установлено значение `true` и несколько потоков пытаются получить блокировку, JVM отдаст приоритет самому долго
ожидающему потоку и предоставит доступ к блокировке.

Тем не менее, использование данного параметра оказывает отрицательное влияние на производительность механизма
блокировки.

**Read/Write Locks**

Другой мощный механизм, который можно использовать для достижения потоко-безопасности — это использование реализаций
`ReadWriteLock`.

Блокировка `ReadWriteLock` фактически использует пару связанных блокировок, одну только для операций чтения, а другую
только для операций записи. В результате может быть много потоков, читающих ресурс, пока нет ни одного потока,
записывающего в него. Более того, поток, пишущий в ресурс, не позволит другим потокам прочитать его.

Мы можем использовать блокировку `ReadWriteLock` следующим образом:

```java
public class ReentrantReadWriteLockCounter {
    private int counter;
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    
    public void incrementCounter() {
        writeLock.lock();
        try {
            counter += 1;
        } finally {
            writeLock.unlock();
        }
    }
    
    public int getCounter() {
        readLock.lock();
        try {
            return counter;
        } finally {
            readLock.unlock();
        }
    }

   // standard constructors
}
```

</details>

<details><summary markdown="span">Volatile Fields</summary>

Синхронизированные методы и блоки удобны для решения проблем с видимостью переменных среди потоков. Даже в этом случае
значения обычных полей класса могут кэшироваться процессором (в регистры процессора). Следовательно, последующие
обновления определенного поля, даже если они синхронизированы, могут быть невидимы для других потоков.

Для предотвращения такой ситуации можно использовать модификатор volatile у поля класса. С помощью ключевого слова
volatile мы указываем JVM и компилятору хранить переменную в основной памяти (в heap). Таким образом, мы гарантируем,
что каждый раз, когда JVM считывает значение переменной, она фактически будет считывать его из основной памяти (heap), а
не из кеша ЦП. Аналогично, каждый раз, когда JVM записывает в переменную, значение будет записываться в основную
память (heap).

Кроме того, использование volatile-переменной гарантирует, что все переменные, видимые данному потоку, также будут
считаны из основной памяти, рассмотрим пример:

```java
public class User {
    private String name;
    private volatile int age;

    // standard constructors / getters
}
```

Каждый раз, когда JVM записывает volatile переменную age в основную память, она также записывает
не volatile переменную name в основную память. Это гарантирует, что последние значения обеих переменных будут
храниться в основной памяти, поэтому последующие обновления переменных будут автоматически видны другим потокам.

Если поток считывает значение volatile переменной, все переменные, видимые потоку, также будут считаны из основной
памяти.

Эта расширенная гарантия, которую обеспечивают переменные volatile,
известна [full volatile visibility guarantee](http://tutorials.jenkov.com/java-concurrency/volatile.html).

</details>

<details><summary markdown="span">Thread-safe Collections</summary>

Мы можем использовать потоко-безопасные реализации коллекций.

**Synchronized Collections**

Например, мы можем обернуть любую существующую коллекцию в потоко-безопасную обертку (synchronization wrapper):

```java
Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
Thread thread1 = new Thread(() -> syncCollection.addAll(Arrays.asList(1, 2, 3, 4, 5, 6)));
Thread thread2 = new Thread(() -> syncCollection.addAll(Arrays.asList(7, 8, 9, 10, 11, 12)));
thread1.start();
thread2.start();
```

Стоит понимать, что синхронизированные коллекции используют внутреннюю блокировку в каждом методе (делают метод
synchronized) без анализа необходимости или минимальных блоков кода, на самом деле, подлежащих синхронизации, что может
приводить к значительному падению производительности.

Тем не менее, это означает, что к методам может обращаться только один поток за раз, в то время как другие потоки будут
заблокированы до тех пор, пока метод не будет разблокирован первым потоком.

**Concurrent Collections**

В качестве альтернативы Synchronized Collections мы можем использовать Concurrent Collections для создания
потокобезопасных коллекций.

Java в рамках пакета `java.util.concurrent` предоставляет ряд concurrent collections, например `ConcurrentHashMap`:

```java
Map<String,String> concurrentMap = new ConcurrentHashMap<>();
concurrentMap.put("1", "one");
concurrentMap.put("2", "two");
concurrentMap.put("3", "three");
```

В отличие от своих Synchronized Collections, Concurrent Collections обеспечивают потокобезопасность за счет
разделения своих данных на сегменты. Например, в `ConcurrentHashMap` несколько потоков могут получать блокировки на разных
сегментах `Map`, поэтому несколько потоков могут получить доступ к `Map` одновременно.

Concurrent Collections намного более эффективны, чем Synchronized Collections, благодаря неотъемлемым преимуществам
параллельного доступа к потокам, достигнутым за счет суженеия сегментов блокировки данных до реально необходимых и
выполнения ряды иных оптимизаций.

Стоит отметить, что как Synchronized, так и Concurrent Collections делают потокобезопасной только саму коллекцию, а не
ее содержимое.

</details>

<details><summary markdown="span">Atomic Objects</summary>

Также возможно обеспечить потоко-безопасность с помощью набора атомарных классов, предоставляемых Java, включая
`AtomicInteger`, `AtomicLong`, `AtomicBoolean` и `AtomicReference`.

Атомарные классы позволяют нам выполнять атомарные операции, которые являются потокобезопасными, без использования
синхронизации. Атомарная операция выполняется в рамках единой, неделимой операции на машинном уровне.

Рассмотрим пример:

```java
public class Counter {
    private int counter = 0;
    
    public void incrementCounter() {
        counter++;
    }
    
    public int getCounter() {
        return counter;
    }
}
```

Предположим, следующий race condition: два потока одновременно обращаются к методу `incrementCounter()`. В теории,
значение поля счетчика должно бы стать равным 2. Но мы просто не можем быть уверены в результате, потому что потоки
одновременно выполняют один и тот же блок кода, а приращение (incrementation) не является атомарным.

Дело в том, что на машинном уровне оператор `++` не является атомарным, т.е. выполняет более одной последовательной
операции:
1. сначала вычитывает текущее значение переменной;
2. затем увеличивает на 1 вычитанное значение;
3. записывает увеличенное значение обратно в соответствующую область памяти.

Давайте создадим потоко-безопасную реализацию счетчика, используя `AtomicInteger`:

```java
public class AtomicCounter {
    private final AtomicInteger counter = new AtomicInteger();
    
    public void incrementCounter() {
        counter.incrementAndGet();
    }
    
    public int getCounter() {
        return counter.get();
    }
}
```

Это потокобезопасно, потому что incrementAndGet() является атомарным, т.к. он для выполнения этой операции использует
специальную атомарную инструкцию процессора - CAS (compare and swap).

</details>

Подробнее см. [здесь](https://www.baeldung.com/java-thread-safety) и [здесь](https://shipilev.net/blog/2014/safe-public-construction/).

</details>

---

#### Будет ли ошибка, если вызвать wait не из блока synchronize?

Будет сгенерировано исключение `java.lang.IllegalMonitorStateException`.

---

#### Использовали ли Вы что-то из пакета java.concurrent.atomic?

<details><summary markdown="span">Ответ</summary>

Набор атомарных классов, предоставляемых Java в рамках пакета `java.concurrent.atomic` (`AtomicInteger`, `AtomicLong`,
`AtomicBoolean` и `AtomicReference`) являются одним из возможных механизмов реализации потоко-безопасности.

Атомарные классы позволяют нам выполнять атомарные операции, которые являются потокобезопасными, без использования
синхронизации. Атомарная операция выполняется в рамках единой, неделимой операции на машинном уровне.

Рассмотрим пример:

```java
public class Counter {
    private int counter = 0;
    
    public void incrementCounter() {
        counter++;
    }
    
    public int getCounter() {
        return counter;
    }
}
```

Предположим, следующий race condition: два потока одновременно обращаются к методу `incrementCounter()`. В теории,
значение поля счетчика должно бы стать равным 2. Но мы просто не можем быть уверены в результате, потому что потоки
одновременно выполняют один и тот же блок кода, а приращение (incrementation) не является атомарным.

Дело в том, что на машинном уровне оператор `++` не является атомарным, т.е. выполняет более одной последовательной
операции:
1. сначала вычитывает текущее значение переменной;
2. затем увеличивает на 1 вычитанное значение;
3. записывает увеличенное значение обратно в соответствующую область памяти.

Давайте создадим потоко-безопасную реализацию счетчика, используя `AtomicInteger`:

```java
public class AtomicCounter {
    private final AtomicInteger counter = new AtomicInteger();
    
    public void incrementCounter() {
        counter.incrementAndGet();
    }
    
    public int getCounter() {
        return counter.get();
    }
}
```

Это потоко-безопасно, потому что incrementAndGet() является атомарным, т.к. он для выполнения этой операции использует
специальную атомарную инструкцию процессора - CAS (compare and swap).

</details>

---

#### optimistic vs pessimistic lock

Существует два различных механизма блокировки ресурсов для их консистентного обновления (обновления без каких-либо
обновленных данных).

<details><summary markdown="span">Pessimistic Lock</summary>

Оптимистическая блокировка - это стратегия, при которой:
1. выполняет захват записи (в БД) на write (для работы с ней в монопольном режиме);
2. выполняется обновление записи (в БД);
3. выполняется освобождение захваченной на write записи (в БД).

</details>

<details><summary markdown="span">Optimistic Lock</summary>

Оптимистическая блокировка - это стратегия, при которой:
1. вычитается запись (из БД);
2. запоминается версия (должна храниться в одном из полей записи в БД);
3. выполняются какие-то действия над записью (обновляется запись);
4. записывается обновленная версия записи (в БД):
- у записи увеличивается значение счетчика в поле версии:
    - `version = version + 1`;
- при записи используется фильтрация по полю версии, где указывается значение на момент чтения записи:
    - `where version = yourEarlyReadVersion`.

В итоге имеем два возможных результата:

- запись была успено обновлена (успешно попала под условие `where`):
    - значит все действия между чтением и записью данных в БД выполнились атомарно (никто не изменял данные в БД в этот
      интервал времени):
        - благоприятный исход, двигаемся дальше;
- запись не была обновлена (не попала под под условие `where`):
    - значит где-то между нашим чтением и записью данных в БД кто-то изменил данные:
        - неблогоприятный исход, требуется либо снова вычитать запись из БД и повторить все выполненные действия, либо
          откатывать все выполненные действия в этот промежуток времени.

Другими словами, данный вид блокировки вовсе никогда и не блокирует данные, он лишь оптимистично надеется, что данные не
будут изменены в промежуток времени между его операцией чтения и записи.

</details>

---

#### Расскажите про synchronize блоки и методы, чем отличаются? Что такое монитор?

<details><summary markdown="span">Synchronized Methods & Statements</summary>

**Synchronized Methods**

Если нам требуется, чтобы только один поток могу получить доступ к методу одновременно, блокируя доступ к этому методу
из других потоков, то можно воспользоваться модификатором метода - `synchronized`. Другие потоки останутся
заблокированными до тех пор, пока не завершится первый поток или пока метод не вызовет исключение.

Например, таким образом мы можем создать потоко-безопасную версию `incrementCounter()`:

```java
public synchronized void incrementCounter() {
    counter += 1;
}
```

Так как один поток за раз может получить доступ к `synchronized` методу, один поток будет выполнять метод
`incrementCounter()`, а другие, в свою очередь, будут делать то же самое. Никакого перекрывающегося выполнения не
произойдет.

`synchronized` методы основаны на использовании «внутренних блокировок» или «блокировок монитора». Внутренняя
блокировка - это неявный внутренний объект, связанный с конкретным экземпляром класса.

В многопоточном контексте термин «монитор» — это просто ссылка на экземпляр объекта, используемый в качестве сущности,
к которой привязывается блокировка, обеспечивая монопольный доступ к набору указанных методов или операторов,
заключенных в рамки конструкции синхронизации.

Когда поток вызывает `synchronized` метод, он выполняет блокировк (захватывает монитор). После того, как поток завершает
выполнение метода, он освобождает блокировку (отпускает монитор), позволяя другим потокам получить блокировку и доступ к
методу.

Мы можем реализовать синхронизацию в методах экземпляра класса, статических методах класса и операторах (см. далее
synchronized statements).

**Synchronized Statements**

Иногда синхронизация всего метода может быть излишней, если нам просто нужно сделать сегмент метода потокобезопасным.
Синхронизация стоит дорого, поэтому выгоднее синхронизировать только соответствующие части метода.

Чтобы проиллюстрировать этот вариант использования, давайте несколько изменим метод `incrementCounter()`:

```java
public void incrementCounter() {
    // additional unsynced operations
    synchronized(this) {
        counter += 1; 
    }
}
```

В отличие от синхронизированных методов, синхронизированные операторы должны указывать объект, обеспечивающий встроенную
блокировку. В пример выше используется ссылка на текущий объект класса (`this`).

Мы можем немного улучшить потокобезопасную реализацию класса `Counter`, используя вместо этого другой объект в качестве
блокировки монитора:

```java
public class ObjectLockCounter {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void incrementCounter() {
        synchronized(lock) {
            counter += 1;
        }
    }
    
    // standard getter
}
```

Мы используем ничего не делающий экземпляр класса `Object` в качестве монитора, т.е. для построения блокировки поверх
него.

**Предостережения**

Несмотря на то, что мы можем использовать любой объект Java в качестве встроенной блокировки, следует избегать
использования String для целей блокировки:

```java
public class Class1 {
    private static final String LOCK  = "Lock";

    // uses the LOCK as the intrinsic lock
}

public class Class2 {
    private static final String LOCK  = "Lock";

    // uses the LOCK as the intrinsic lock
}
```

На первый взгляд кажется, что эти два класса используют в качестве блокировки два разных объекта. Однако из-за эффекта
оптимизирующего работу со строками, интернирования строк (String interning), эти два значения `Lock` могут на самом
деле ссылаться на один и тот же объект в пуле строк. То есть `Class1` и `Class2` используют одну и ту же блокировку.

Это, в свою очередь, может привести к неожиданному поведению в параллельных контекстах.

В дополнение к `String` мы должны избегать использования каких-либо кэшируемых или повторно используемых объектов в
качестве мониторов для блокировок. Например, метод `Integer.valueOf()` кэширует небольшие числа (на отрезке от `-128`
до `127`). Поэтому вызов
`Integer.valueOf(1)` возвращает один и тот же объект даже в разных классах.

</details>

---

#### Как я могу пустить не один поток в синхронизированный блок, а например не больше пяти?

Использовать класс `java.util.concurrent.Semaphore`:

```java
public class Example {
  public static void main(String[] args) {
    Semaphore semaphore = new Semaphore(5);
    startThread(semaphore); // 1
    startThread(semaphore); // 2
    startThread(semaphore); // 3
    startThread(semaphore); // 4
    startThread(semaphore); // 5
    startThread(semaphore); // 6
  }

  public static void startThread(Semaphore semaphore) {
    new Thread(new Runnable() {
      @Override
      @SneakyThrows
      public void run() {
        semaphore.acquire();
        try {
          TimeUnit.SECONDS.sleep(1); // здесь должен быть ваш код
        } finally {
          semaphore.release();
        }
      }
    }).start();
  }
}
```

Подробнее см. [здесь](https://habr.com/ru/post/277669/).

---

#### Влияет ли как то volatile на оптимизации, выполняемые JVM?

В JMM (java memory model) существует отношение happens before, согласно которому при чтении и записи:

- Любые зависимости по данным (то есть запись в любую переменную и последующее чтение её же) в одном потоке.
- Всё, что в том же потоке перед записью в volatile-переменную, и сама запись.
- volatile-чтение и всё, что после него в том же потоке.
- Запись в volatile-переменную и последующее считывание её же.
    - Таким образом, volatile-запись делает с памятью то же, что возврат монитора, а чтение — то же, что захват. А значит:
      если один поток записал в volatile-переменную, а второй обнаружил это, всё, что предшествует записи, выполняется
      раньше всего, что идёт после чтения; см. иллюстрацию.
    - Для объектных переменных (например, `volatile List x;`) столь сильные гарантии выполняются для ссылки на объект, но
      не для его содержимого.

![Happens Before](se/images/concurrency/happens-before.png)

Другими словами, согласно данной концепции потокам запрещено кэшировать значения volatile переменных в рамках своих
регистрах (они обязаны при каждом чтении заново вычитывать значение из основной памяти (heap)).

---

#### Назовите concurrent коллекцию

Существуют synchronized и concurrent collections.

Synchronized коллекции - это просто обертки над обычными коллекциями, которые используют внутреннюю блокировку в каждом
методе (делают метод synchronized) без анализа необходимости или минимальных блоков кода, на самом деле, подлежащих
синхронизации, что может приводить к значительному падению производительности.

Например, мы можем обернуть любую существующую коллекцию в потоко-безопасную обертку (synchronization wrapper):

```java
Collection<Integer> syncCollection = Collections.synchronizedCollection(new ArrayList<>());
```

В качестве альтернативы Synchronized Collections мы можем использовать Concurrent Collections для создания
потокобезопасных коллекций.

Java в рамках пакета `java.util.concurrent` предоставляет ряд concurrent collections, например:
- `ConcurrentHashMap`;
- `ConcurrentSkipListMap`;
- `CopyOnWriteArrayList`;
- `ArrayBlockingQueue`;
- `LinkedBlockingQueue`.

ToDo: описать в двух словах каждую коллекцию.

---

#### Как осуществляется распараллеливание в ConcurrentHashMap?

При необходимости изменения/вставки данных блокировка выполняется лишь на уровне bucket (корзины), а не всей коллекции.

Подробнее см. концепцию устройства обычной `HashMap`.

---

#### Что такое livelock и deadlock

<details><summary markdown="span">Deadlock</summary>

Deadlock или взаимная блокировка — это ошибка, которая происходит когда процессы имеют циклическую зависимость от пары
синхронизированных объектов.

Deadlock — это программа, в которой все параллельные процессы ожидают друг друга. В этом состоянии программа никогда не
восстановится без вмешательства извне.

![Deadlock in life](se/images/concurrency/deadlock_cars.png)

![Deadlock in programming](se/images/concurrency/deadlock_threads.png)

</details>

<details><summary markdown="span">Livelock</summary>

Livelock- это программы, которые активно выполняют параллельные операции, но эти операции никак не влияют на продвижение
состояния программы вперед.

Ситуация, в которой два или более процессов непрерывно изменяют свои состояния в ответ на изменения в других процессах
без какой-либо полезной работы. Это похоже на deadlock, но разница в том, что процессы становятся “вежливыми” и
позволяют другим делать свою работу.

Выполнение алгоритмов поиска удаления взаимных блокировок может привести к livelock — взаимная блокировка образуется,
сбрасывается, снова образуется, снова сбрасывается и так далее.

Жизненный пример такой ситуации:

> Двое встречаются лицом к лицу. Каждый из них пытается посторониться, но они не расходятся, а несколько секунд сдвигаются в одну и ту же сторону.
> Вы делаете телефонный звонок, но человек на другом конце тоже пытается вам позвонить.
> Вы оба повесите трубку и попробуйте снова через одно и то же время, что снова создаст такую же ситуацию.
> Это может продолжаться вечность.

</details>

Подробнее см. [здесь](https://medium.com/german-gorelkin/deadlocks-livelocks-starvation-ccd22d06f3ae).

---

#### Расскажите про структуру исключений. Что значит обрабатываемые и необрабатываемые исключения?

Исключением в java считается любой класс, наследник класса Throwable. Тем не мене, кроме Throwable в java имеется
некоторая предопределенная иерархия наследования классов исключений от Throwable.

Базовая часть иерархии стандартных классов исключений:
- Throwable
    - Exception
        - RuntimeException
    - Error
        - VirtualMachineError
        - AssertionError
        - ThreadDeath

Логически исключения делятся на два типа:
- непроверяемые:
    - RuntimeException и все его наследники;
    - Error и все его наследники;
- проверяемые:
    - все остальные (Throwable, а также Exception и все его наследники).

Эти два типа исключения имеют несколько отличающуюся семантику обработки в java:
- проверяемые:
    - на этапе компиляции кода проверяется, если в рамках метода генерируется проверяемое исключение, то оно либо должно
      быть явным образом отловлено и обработано (try / catch), либо должно быть явным образом объявлено в сигнатуре
      метода (сигнализируя о том, что из данного метода может "вылететь" исключение);
- непроверяемые:
    - не накладывают никаких требований к их обработке на этапе компиляции.

---

#### Могу ли я создавать свои исключения?

Да, для этого достаточно создать наследника от любого из классов исключений (см. ответы выше про иерархию исключений).

---

#### Как в коде мне получить StackOverflow и OutOfMemory намеренно?

StackOverflowError (переполнение stack):
- в рамках одного потока устроить бесконечную рекурсию (вызвать метод, который бесконечно вызывает сам себя):
    - в итоге в stack рано или поздно закончится память (по умолчанию, в java на stack потоку выделяется 512 KiB):
        - в stack будут бесконечно вложено размещаться stack frame'ы (т.е. шаги исполнения кода и состояния переменных в них).

OutOfMemoryError (переполнение heap):
- бесконечно создавать крупные байтовые массивы, при этом не теряя ссылки на них (например, размещая их в List):
    - рано или поздно доступный Heap у JVM закончится и будет получена ошибка.